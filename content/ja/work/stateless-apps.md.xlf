<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/stateless-apps.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja" state="translated">それは何ですか</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">A stateless application doesn’t save any client session (state) data on the server where the application lives.
Each session is carried out as if it was the first time and responses are not dependent upon data from a previous session and
provides functionality to use print services, CDN (Content Delivery Network) or the Web Servers
in order to process every short-term request.
For example, someone is searching a question in the search engine and pressed the Enter button.
In case if the searching operation gets interrupted or closed due to some reason,
you have to start a new one as there is no saved data for your previous request.</source>
<target xml:lang="ja" state="translated">ステートレス アプリケーションは、アプリケーションが存在するサーバーにクライアント セッション (状態) データを保存しません。
各セッションは初回の場合と同じように実行され、応答は前のセッションのデータに依存せず、
印刷サービス、CDN (コンテンツ配信ネットワーク)、または Web サーバーを使用する機能を提供します
すべての短期的なリクエストを処理するため。
たとえば、誰かが検索エンジンで質問を検索していて、Enter ボタンを押したとします。
何らかの理由で検索操作が中断または終了した場合は、
以前のリクエストの保存データがないため、新しいリクエストを開始する必要があります。</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja" state="translated">対処する問題</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Stateless applications tackle the problem of resiliency,
because different pods across a <x id="1"/>cluster<x id="2"/> can work independently,
with multiple requests coming to them at the same time.
If there’s a problem, you can easily restart the application,
and it will return to its initial state with little or no downtime.
As such, the benefits of stateless applications include resiliency, elasticity, and high availability.
However, most applications we use today are at least partly <x id="3"/>stateful<x id="4"/>,
as they store things like preferences and settings to improve the user experience.</source>
<target xml:lang="ja" state="translated">ステートレス アプリケーションは回復力の問題に取り組み、
<x id="1"/>クラスタ<x id="2"/>全体の異なるポッドが独立して動作できるため、
同時に複数のリクエストが送信されます。
問題が発生した場合は、アプリケーションを簡単に再起動できます。
ダウンタイムがほとんどまたはまったくない状態で、初期状態に戻ります。
そのため、ステートレス アプリケーションの利点には、回復力、弾力性、および高可用性が含まれます。
ただし、現在使用しているほとんどのアプリケーションは、少なくとも部分的に<x id="3"/>ステートフル<x id="4"/>です。
ユーザーエクスペリエンスを向上させるために、設定や設定などを保存するためです。</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja" state="translated">どのように役立つか</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Boiling everything down, in a Stateless Application the only thing your cluster is responsible for is
the code, and other static content, being hosted on it.
That’s it, no changing databases, no writes and no left over files when the pod is deleted.
Stateless <x id="1"/>containers<x id="2"/> are easier to deploy,
and you don’t need to worry about saving container data on persistent storage volumes.
You also don't have to worry about backing up the data.</source>
<target xml:lang="ja" state="translated">すべてを要約すると、ステートレス アプリケーションでは、クラスタが担当するのは
その上でホストされているコードおよびその他の静的コンテンツ。
それだけです。ポッドが削除されたときに、データベースの変更、書き込み、ファイルの残りはありません。
ステートレス <x id="1"/>コンテナ<x id="2"/> はデプロイが簡単です。
コンテナ データを永続ストレージ ボリュームに保存することについて心配する必要はありません。
データのバックアップについても心配する必要はありません。</target>
</trans-unit>
</body>
</file>
</xliff>
