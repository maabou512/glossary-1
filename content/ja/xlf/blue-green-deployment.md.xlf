<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/blue-green-deployment.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja">What it is</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">Blue-green deployment is a strategy for updating running computer systems with minimal downtime.
The operator maintains two environments, dubbed “blue” and “green”.
One serves production traffic (the version all users are currently using), whilst the other is updated.
Once testing has concluded on the non-active (green) environment,
production traffic is switched over (often via the use of a <x id="1"/>load balancer<x id="2"/>).
Note that blue-green deployment usually means switching the entire environments, comprising many <x id="3"/>services<x id="4"/>, all at once.
Confusingly, sometimes the term is used with regard to individual services within a system.
To avoid this ambiguity, the term “zero-downtime deployment” is preferred when referring to individual components.</source>
<target xml:lang="ja">Blue-green deployment is a strategy for updating running computer systems with minimal downtime.
The operator maintains two environments, dubbed “blue” and “green”.
One serves production traffic (the version all users are currently using), whilst the other is updated.
Once testing has concluded on the non-active (green) environment,
production traffic is switched over (often via the use of a <x id="1"/>load balancer<x id="2"/>).
Note that blue-green deployment usually means switching the entire environments, comprising many <x id="3"/>services<x id="4"/>, all at once.
Confusingly, sometimes the term is used with regard to individual services within a system.
To avoid this ambiguity, the term “zero-downtime deployment” is preferred when referring to individual components.</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja">Problem it addresses</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Blue-green deployments allow minimal downtime when updating software that must be changed in "lockstep" owing to a lack of backwards compatibility.
For example, blue-green deployment would be appropriate for an online store
consisting of a website and a database that needs to be updated,
but the new version of the database doesn’t work with the old version of the website, and vice versa.
In this instance, both need to be changed at the same time.
If this was done on the production system, customers would notice downtime.</source>
<target xml:lang="ja">Blue-green deployments allow minimal downtime when updating software that must be changed in "lockstep" owing to a lack of backwards compatibility.
For example, blue-green deployment would be appropriate for an online store
consisting of a website and a database that needs to be updated,
but the new version of the database doesn’t work with the old version of the website, and vice versa.
In this instance, both need to be changed at the same time.
If this was done on the production system, customers would notice downtime.</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja">How it helps</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Blue-green deployment is an appropriate strategy for non-cloud native software that needs to be updated with minimal downtime.
However, its use is normally a "smell" that legacy software needs to be re-engineered so that components can be updated individually.</source>
<target xml:lang="ja">Blue-green deployment is an appropriate strategy for non-cloud native software that needs to be updated with minimal downtime.
However, its use is normally a "smell" that legacy software needs to be re-engineered so that components can be updated individually.</target>
</trans-unit>
</body>
</file>
</xliff>
