<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/client-server-architecture.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja">What it is</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">In a client-server architecture, the logic (or code) that makes up an application is split between two or more components:
a client that asks for work to be done
(e.g. the Gmail web application running in your web browser),
and one or more servers that satisfy that request
(e.g. the "send email" service running on Google’s computers in the cloud).
In this example, outgoing emails that you write are sent by the client (web application running in your web browser)
to a server (Gmail's computers, which forward your outgoing emails to their recipients).</source>
<target xml:lang="ja">In a client-server architecture, the logic (or code) that makes up an application is split between two or more components:
a client that asks for work to be done
(e.g. the Gmail web application running in your web browser),
and one or more servers that satisfy that request
(e.g. the "send email" service running on Google’s computers in the cloud).
In this example, outgoing emails that you write are sent by the client (web application running in your web browser)
to a server (Gmail's computers, which forward your outgoing emails to their recipients).</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">This contrasts with self-contained applications (such as desktop applications) that do all the work in one place.
For example, a word processing program like Microsoft Word may be installed and run entirely on your computer.</source>
<target xml:lang="ja">This contrasts with self-contained applications (such as desktop applications) that do all the work in one place.
For example, a word processing program like Microsoft Word may be installed and run entirely on your computer.</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja">Problem it addresses</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">A client-server architecture solves a big challenge self-contained applications pose: regular updates.
In a self-contained app, for each update, users would have to download and install the latest version.
Imagine having to download all of Amazon’s product catalog to your own computer before being able to browse it!</source>
<target xml:lang="ja">A client-server architecture solves a big challenge self-contained applications pose: regular updates.
In a self-contained app, for each update, users would have to download and install the latest version.
Imagine having to download all of Amazon’s product catalog to your own computer before being able to browse it!</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja">How it helps</target>
</trans-unit>
<trans-unit id="tu7" xml:space="preserve">
<source xml:lang="en">By implementing application logic in a remote server or service,
operators can update that without needing to change the logic on the client-side.
This means updates can be made much more frequently.
Storing data on the server allows many clients to all see and share the same data.
Consider the difference between using an online word processor, compared to a traditional offline word processor.
In the former, your files exist on the server-side and
can be shared with other users who simply download them from the server.
In the legacy world, files needed to be copied to removable media (floppy disks!) and shared with individuals.</source>
<target xml:lang="ja">By implementing application logic in a remote server or service,
operators can update that without needing to change the logic on the client-side.
This means updates can be made much more frequently.
Storing data on the server allows many clients to all see and share the same data.
Consider the difference between using an online word processor, compared to a traditional offline word processor.
In the former, your files exist on the server-side and
can be shared with other users who simply download them from the server.
In the legacy world, files needed to be copied to removable media (floppy disks!) and shared with individuals.</target>
</trans-unit>
</body>
</file>
</xliff>
