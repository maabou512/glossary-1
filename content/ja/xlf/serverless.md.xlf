<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/serverless.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja">What it is</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">Serverless is a cloud native development model that allows developers to
build and run applications without having to manage servers.
There are still servers in serverless, but they are <x id="1"/>abstracted<x id="2"/> away from app development.
A cloud provider handles the routine work of provisioning, maintaining, and <x id="3"/>scaling<x id="4"/> the server infrastructure.
Developers can simply package their code in <x id="5"/>containers<x id="6"/> for deployment.
Once deployed, serverless apps respond to demand and automatically scale up and down as needed.
Serverless offerings from public cloud providers are usually metered on-demand through an event-driven execution model.
As a result, when a serverless function is sitting idle, it doesn’t cost anything.</source>
<target xml:lang="ja">Serverless is a cloud native development model that allows developers to
build and run applications without having to manage servers.
There are still servers in serverless, but they are <x id="1"/>abstracted<x id="2"/> away from app development.
A cloud provider handles the routine work of provisioning, maintaining, and <x id="3"/>scaling<x id="4"/> the server infrastructure.
Developers can simply package their code in <x id="5"/>containers<x id="6"/> for deployment.
Once deployed, serverless apps respond to demand and automatically scale up and down as needed.
Serverless offerings from public cloud providers are usually metered on-demand through an event-driven execution model.
As a result, when a serverless function is sitting idle, it doesn’t cost anything.</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja">Problem it addresses</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Under a standard <x id="1"/>Infrastructure-as-a-Service (IaaS)<x id="2"/> <x id="3"/>cloud computing<x id="4"/> model,
users pre-purchase units of capacity, meaning you pay a public cloud provider for always-on server components to run your apps.
It’s the user’s responsibility to scale up server capacity during times of high demand and
to scale down when that capacity is no longer needed.
The cloud infrastructure necessary to run an app is active even when the app isn’t being used.</source>
<target xml:lang="ja">Under a standard <x id="1"/>Infrastructure-as-a-Service (IaaS)<x id="2"/> <x id="3"/>cloud computing<x id="4"/> model,
users pre-purchase units of capacity, meaning you pay a public cloud provider for always-on server components to run your apps.
It’s the user’s responsibility to scale up server capacity during times of high demand and
to scale down when that capacity is no longer needed.
The cloud infrastructure necessary to run an app is active even when the app isn’t being used.</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja">How it helps</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">With serverless architecture, by contrast, apps are launched only as needed.
When an event triggers app code to run, the public cloud provider dynamically allocates resources for that code.
The user stops paying when the code finishes executing.
In addition to the cost and efficiency benefits,
serverless frees developers from routine and menial tasks associated with app scaling and server provisioning.
With serverless, routine tasks such as managing the operating system and file system, security patches,
load balancing, capacity management, scaling, logging, and monitoring are all offloaded to a cloud services provider.</source>
<target xml:lang="ja">With serverless architecture, by contrast, apps are launched only as needed.
When an event triggers app code to run, the public cloud provider dynamically allocates resources for that code.
The user stops paying when the code finishes executing.
In addition to the cost and efficiency benefits,
serverless frees developers from routine and menial tasks associated with app scaling and server provisioning.
With serverless, routine tasks such as managing the operating system and file system, security patches,
load balancing, capacity management, scaling, logging, and monitoring are all offloaded to a cloud services provider.</target>
</trans-unit>
</body>
</file>
</xliff>
