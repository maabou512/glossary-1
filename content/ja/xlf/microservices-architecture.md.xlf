<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/microservices-architecture.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja">What it is</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">A microservices architecture is an architectural approach that breaks applications into individual independent (micro)<x id="1"/>services<x id="2"/>, with each service focused on a specific functionality.
These services work together closely, appearing to the end user as a single entity.
Take Netflix as an example.
Its interface allows you to access, search, and preview videos.
These capabilities are likely powered by smaller services that each handle one functionality, e.g., authentication, search, and running previews in your browser.</source>
<target xml:lang="ja">A microservices architecture is an architectural approach that breaks applications into individual independent (micro)<x id="1"/>services<x id="2"/>, with each service focused on a specific functionality.
These services work together closely, appearing to the end user as a single entity.
Take Netflix as an example.
Its interface allows you to access, search, and preview videos.
These capabilities are likely powered by smaller services that each handle one functionality, e.g., authentication, search, and running previews in your browser.</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">This architectural approach allows developers to push out new features or update functionality much faster than if they were all tightly coupled, such as in a <x id="1"/>monolithic application<x id="2"/> (more to that below).</source>
<target xml:lang="ja">This architectural approach allows developers to push out new features or update functionality much faster than if they were all tightly coupled, such as in a <x id="1"/>monolithic application<x id="2"/> (more to that below).</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja">Problem it addresses</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">Applications are made up of different parts, each responsible for a specific capability.
Demand for a particular functionality will not necessarily increase or decrease with demand for other app parts.
Going back to our Netflix example.
Let's say that after a big marketing campaign, Netflix experiences a big spike in signups, but streaming has remained more or less stable in the early hours of the day.
The surge in signups demands more signup capacity.
Traditionally (monolithic approach), the entire app would have to be <x id="1"/>scaled<x id="2"/> to accommodate the increase — a very inefficient use of resources.</source>
<target xml:lang="ja">Applications are made up of different parts, each responsible for a specific capability.
Demand for a particular functionality will not necessarily increase or decrease with demand for other app parts.
Going back to our Netflix example.
Let's say that after a big marketing campaign, Netflix experiences a big spike in signups, but streaming has remained more or less stable in the early hours of the day.
The surge in signups demands more signup capacity.
Traditionally (monolithic approach), the entire app would have to be <x id="1"/>scaled<x id="2"/> to accommodate the increase — a very inefficient use of resources.</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Monolithic architectures also make it easy for developers to succumb to design pitfalls.
Because all the code is in one place, it is easier to make that code <x id="1"/>tightly coupled<x id="2"/> and harder to enforce the principle of separation of concerns.
Monoliths also often require developers to understand the entire codebase before deploying any chances.
Microservices architecture is a response to these challenges.</source>
<target xml:lang="ja">Monolithic architectures also make it easy for developers to succumb to design pitfalls.
Because all the code is in one place, it is easier to make that code <x id="1"/>tightly coupled<x id="2"/> and harder to enforce the principle of separation of concerns.
Monoliths also often require developers to understand the entire codebase before deploying any chances.
Microservices architecture is a response to these challenges.</target>
</trans-unit>
<trans-unit id="tu7" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja">How it helps</target>
</trans-unit>
<trans-unit id="tu8" xml:space="preserve">
<source xml:lang="en">Separating functionality into different microservices makes them easier to deploy, update, and scale independently.
It also allows different teams to work simultaneously on a small part of a bigger application without inadvertently negatively impacting the rest of the app.
While a microservices architecture solves many problems, it also creates operational overhead — the things you need to deploy and keep track of increase by order of magnitude.
Many <x id="1"/>cloud-native technologies<x id="2"/> aim to make microservices easier to deploy and manage.</source>
<target xml:lang="ja">Separating functionality into different microservices makes them easier to deploy, update, and scale independently.
It also allows different teams to work simultaneously on a small part of a bigger application without inadvertently negatively impacting the rest of the app.
While a microservices architecture solves many problems, it also creates operational overhead — the things you need to deploy and keep track of increase by order of magnitude.
Many <x id="1"/>cloud-native technologies<x id="2"/> aim to make microservices easier to deploy and manage.</target>
</trans-unit>
</body>
</file>
</xliff>
