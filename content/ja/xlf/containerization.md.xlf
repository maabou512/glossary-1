<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:okp="okapi-framework:xliff-extensions" xmlns:its="http://www.w3.org/2005/11/its" xmlns:itsxlf="http://www.w3.org/ns/its-xliff/" its:version="2.0">
<file original="./en/containerization.md" source-language="en" target-language="ja" datatype="x-text/x-markdown" okp:inputEncoding="UTF-8">
<body>
<trans-unit id="tu1" xml:space="preserve">
<source xml:lang="en">What it is</source>
<target xml:lang="ja">What it is</target>
</trans-unit>
<trans-unit id="tu2" xml:space="preserve">
<source xml:lang="en">Containerization is the process of bundling an application and its dependencies into a <x id="1"/>container image<x id="2"/>.
The container build process requires adherence to the <x id="3"/>Open Container Initiative<x id="4"/> (OCI) standard.
As long as the output is a container image that adheres to this standard, which containerization tool is used doesn't matter.</source>
<target xml:lang="ja">Containerization is the process of bundling an application and its dependencies into a <x id="1"/>container image<x id="2"/>.
The container build process requires adherence to the <x id="3"/>Open Container Initiative<x id="4"/> (OCI) standard.
As long as the output is a container image that adheres to this standard, which containerization tool is used doesn't matter.</target>
</trans-unit>
<trans-unit id="tu3" xml:space="preserve">
<source xml:lang="en">Problem it addresses</source>
<target xml:lang="ja">Problem it addresses</target>
</trans-unit>
<trans-unit id="tu4" xml:space="preserve">
<source xml:lang="en">Before containers became prevalent, organizations relied on virtual machines (VMs) to
orchestrate multiple applications on a single <x id="1"/>bare-metal machine<x id="2"/>.
VMs are significantly larger than containers and require a hypervisor to run.
Due to the storage, backup, and transfer of these larger VM templates, creating the VM templates is also slow.
Additionally, VMs can suffer from configuration drift which violates the principle of <x id="3"/>immutability<x id="4"/>.</source>
<target xml:lang="ja">Before containers became prevalent, organizations relied on virtual machines (VMs) to
orchestrate multiple applications on a single <x id="1"/>bare-metal machine<x id="2"/>.
VMs are significantly larger than containers and require a hypervisor to run.
Due to the storage, backup, and transfer of these larger VM templates, creating the VM templates is also slow.
Additionally, VMs can suffer from configuration drift which violates the principle of <x id="3"/>immutability<x id="4"/>.</target>
</trans-unit>
<trans-unit id="tu5" xml:space="preserve">
<source xml:lang="en">How it helps</source>
<target xml:lang="ja">How it helps</target>
</trans-unit>
<trans-unit id="tu6" xml:space="preserve">
<source xml:lang="en">Container images are lightweight (unlike traditional VMs) and
the containerization process requires a file with a list of dependencies.
This file can be version controlled and the build process automated,
allowing an organization to focus on other priorities
while the automated processes take care of the build.
A container image is stored by a unique identifier
that is tied to its exact content and configuration.
As containers are scheduled and rescheduled,
they are always reset to their initial state which eliminates configuration drift.</source>
<target xml:lang="ja">Container images are lightweight (unlike traditional VMs) and
the containerization process requires a file with a list of dependencies.
This file can be version controlled and the build process automated,
allowing an organization to focus on other priorities
while the automated processes take care of the build.
A container image is stored by a unique identifier
that is tied to its exact content and configuration.
As containers are scheduled and rescheduled,
they are always reset to their initial state which eliminates configuration drift.</target>
</trans-unit>
</body>
</file>
</xliff>
